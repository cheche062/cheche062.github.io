<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CheChe的博客</title>
  <icon>https://www.gravatar.com/avatar/728b28001cd1a0f4b7d79339344cc096</icon>
  <subtitle>吃得苦中苦 心里会更堵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//litten.me/"/>
  <updated>2018-12-09T06:37:44.529Z</updated>
  <id>//litten.me/</id>
  
  <author>
    <name>cheche</name>
    <email>yoojunglee@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络小叙</title>
    <link href="//litten.me/2018/12/08/network-of-computer/"/>
    <id>//litten.me/2018/12/08/network-of-computer/</id>
    <published>2018-12-08T12:09:27.000Z</published>
    <updated>2018-12-09T06:37:44.529Z</updated>
    
    <content type="html"><![CDATA[<p>我们每天都使用的互联网，空间相距遥远的两台计算机是如何实现通信的呢？以下是我的学习笔记。</p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><table><thead><tr><th style="text-align:center">网络的五层模型，由下至上越接近用户，相反越接近硬件</th></tr></thead><tbody><tr><td style="text-align:center">应用层（Application Layer）</td></tr><tr><td style="text-align:center">传输层（Transport Layer）</td></tr><tr><td style="text-align:center">网络层（Network Layer）</td></tr><tr><td style="text-align:center">链接层（Physical Layer）</td></tr><tr><td style="text-align:center">实体层（Physical Layer）</td></tr></tbody></table><p>每一层都有自己的职责与功能以及且必须遵守各自规则，这就叫做”协议”（protocal）。</p><a id="more"></a><h3 id="二、实体层"><a href="#二、实体层" class="headerlink" title="二、实体层"></a>二、实体层</h3><p>实体层最容易理解，就是指物理硬件电脑。要相互通信就得把他们连起来咯，手段就是物理手段”光缆、电缆、无线电波“等方式。</p><blockquote><p>实体层主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p></blockquote><h3 id="三、链接层"><a href="#三、链接层" class="headerlink" title="三、链接层"></a>三、链接层</h3><p><strong> 3.1 定义 </strong><br>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p><blockquote><p>这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p></blockquote><p><strong> 3.2 以太网协议 </strong><br>分组方式这就引出了以太网协议，它规定一组电信号构成一个数据包，叫做“帧”（Frame）。每一帧分为两个部分：</p><ul><li>标头（Head）  包含数据包的说明项，比如发送者、接收者、数据类型等等</li><li>数据（Data）  数据包的具体内容</li></ul><p><strong> 3.2 Mac地址 </strong><br>数据包有了，那么发送者接收者如何标志呢？以太网规定，连入网络的所有设备必须具有“网卡”接口，通过网卡来确定消息的发送和接收者。这就是Mac地址。且每块网卡出厂时都有全世界独一无二的Mac地址，通常用12个十六进制数表示，如“00-B0-D0-86-BB-F7”。</p><p><strong> 3.2 广播 </strong><br>地址有了，那发送者的网卡如何知道接受者的网卡地址呢？ARP协议可以解决这个问题，以太网数据包必须知道接收方的Mac地址然后才能发送。其次怎样将数据包准确的发送给接收者呢？以太网采用了很“原始的方式”，就是向本网络所有计算机发送，让每台计算机自己通过数据包标头内的接受者Mac地址是否是自己的Mac地址。是则接收处理，否则丢弃这个包。这种发送方式就叫做“广播”。<br>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。 </p><h3 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h3><p><strong> 4.1 网络层的由来 </strong><br>以太网协议，依靠MAC地址发送数据，是在两台计算机处于同一个子网络来发送的，互联网是无数个子网络组成的巨型网络。因此必须有个方法来区分哪些Mac地址是处于同一个子网络，如何是同一个子网络则采用广播方式，否则采用“路由”方式。但是Mac地址无法做到这一点，它只与厂商有关，与网络无关。</p><blockquote><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。于是”网络层”出现以后，每台计算机有了两种地址</p><ul><li>MAC地址         （将数据包送到该子网络中的目标网卡）</li><li>网络地址          （帮助我们确定计算机所在的子网络）</li></ul></blockquote><p><strong> 4.2 IP协议 </strong><br>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。所以IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><p><strong> 4.2 IP数据包 </strong><br>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><h3 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h3><p><strong> 5.1 传输层的由来 </strong><br>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。<br>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？<br>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><blockquote><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。</p></blockquote><p><strong> 5.2 TCP协议 </strong><br>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议。TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。</p><h3 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h3><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><blockquote><p>“应用层”的作用，就是规定应用程序的数据格式。</p></blockquote><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。应用层是最接近用户的层，如我们浏览网页用的是HTTP协议，http请求数据包首先嵌入TCP数据包，TCP数据包再嵌入IP数据包，最后IP数据包嵌入以太网数据包。服务器一层层拼接数据包读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。再用TCP协议发回来。本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们每天都使用的互联网，空间相距遥远的两台计算机是如何实现通信的呢？以下是我的学习笔记。&lt;/p&gt;
&lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;网络的五层模型，由下至上越接近用户，相反越接近硬件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;应用层（Application Layer）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;传输层（Transport Layer）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;网络层（Network Layer）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;链接层（Physical Layer）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;实体层（Physical Layer）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每一层都有自己的职责与功能以及且必须遵守各自规则，这就叫做”协议”（protocal）。&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="//litten.me/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="网络" scheme="//litten.me/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Rxjs乱语</title>
    <link href="//litten.me/2018/04/08/Rxjs/"/>
    <id>//litten.me/2018/04/08/Rxjs/</id>
    <published>2018-04-08T07:41:36.000Z</published>
    <updated>2018-12-08T04:54:02.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><blockquote><p>RxJS 是使用 Observables 基于可观测数据流在异步编程应用中的库，它使编写异步或基于回调的代码更容易。</p></blockquote><p>解决异步编程我们已经有了es6的Promise，但Rx是更好的方案。</p><p>优势：</p><ul><li>延迟执行</li><li>可传送多个值</li><li>可中途取消以及重试</li><li>可保留值待后续发送</li><li>函数式编程体验</li></ul><a id="more"></a><h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><h5 id="observable（可被观察对象）、producer-生产者-、observer（观察者）、operator（操作符）、subscription-可退订者"><a href="#observable（可被观察对象）、producer-生产者-、observer（观察者）、operator（操作符）、subscription-可退订者" class="headerlink" title="observable（可被观察对象）、producer (生产者)、observer（观察者）、operator（操作符）、subscription(可退订者)"></a>observable（可被观察对象）、producer (生产者)、observer（观察者）、operator（操作符）、subscription(可退订者)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs/Rx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可观察的被观察者</span></span><br><span class="line"><span class="keyword">let</span> source$ = Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">let</span> producer = &#123;</span><br><span class="line">            val: <span class="number">0</span>,</span><br><span class="line">            nextValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.val = <span class="keyword">this</span>.val + <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        observer.next(producer.nextValue())</span><br><span class="line">        observer.next(producer.nextValue())</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 操作符</span></span><br><span class="line">.map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>)</span><br><span class="line"><span class="comment">//观察者1</span></span><br><span class="line"><span class="keyword">let</span> observer1 = &#123;</span><br><span class="line">    next: <span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A:'</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//观察者2</span></span><br><span class="line"><span class="keyword">let</span> observer2 = &#123;</span><br><span class="line">    next: <span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B:'</span> , val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//观察者3</span></span><br><span class="line"><span class="keyword">let</span> observer2 = &#123;</span><br><span class="line">    next: <span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B:'</span> , val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定订阅</span></span><br><span class="line">source$.subscribe(observer1)</span><br><span class="line">source$.subscribe(observer2)</span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">let</span> subscription = source$.subscribe(observer3)</span><br><span class="line">subscription.unsubscribe();</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// A: 1</span></span><br><span class="line"><span class="comment">// A: 2</span></span><br><span class="line"><span class="comment">// B: 1</span></span><br><span class="line"><span class="comment">// B: 2</span></span><br></pre></td></tr></table></figure><p>上面这个例子来个初体验，通过<code>Observable.create</code>来创建一个可被观察的对象，可理解为一个数据流<code>stream</code>的开端，注意创建时给它传入的回调函数并未立刻执行，这一点需区别于Promise的立刻执行性。</p><p><code>.map()</code>是一个操作符，可将它的意义理解为对数据流进行相应的操作，并将数据流继续向下流。<strong>注意：</strong><code>map</code>操作符的返回值是一个新的<code>observable</code>也就是这里的<code>source$</code>最终的可观测对象！<br>这样实现的目的同样也具有函数式的体验，<strong>不破坏原始数据流</strong>，你可以监听之前的数据流而不受本次操作符所影响。</p><p>接下来的两个观察者<code>observer</code>当然就是监听最终数据，它是一个对象且拥有<code>next</code>方法，该方法往往就是更新视图<code>view</code>了。在对被观察者进行订阅时<code>subscribe</code>传入观察者<code>observer</code>，此时此刻传入<code>Observable.create</code>方法的回调函数才会执行，并开启一个延时100毫秒的定时器。</p><p><code>observer</code>形参可以理解为就是传入的观察者，当然它并不完全是，实际它是由Rx内部重新包装过的标准观察者，目的：一方面是为了兼容使用者的简写变得更简单，另一方面它需要功能扩展的其它全方法规范应用。调用观察者的<code>next</code>方法并给他传值，可以是异步请求的结果值送出，而这边的值也是经过了Rx包装过的通过一个生产者<code>producer</code>处理或者存储再送出，可以发现这里能向外送出多个值。数据会经过<code>map</code>处理将每个值*2，这里也体现了函数式的优势，map操作不参与内部值的生产，只参加数据的操作。</p><p><code>subscription</code>可以取消观察者的订阅！可订可退出！优于<code>promise</code>的无法中途退出的弊端</p><h3 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h3><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><ul><li>用户向输入框输入内容则发送请求数据</li><li>限制用户的请求频率，停止输入后200毫秒后发送</li><li>过滤用户的空内容</li><li>服务端请求结果响应时间是不固定的，所以在下一个请求发出前要忽略本次请求的结果，就是后一个请求要覆盖干掉前者</li><li>将结果进行长度排序</li><li>清空输入框的内容同时展示数据</li><li>给渲染出来的数据子项添加鼠标移入移出的背景变色事件以及点击事件则删除该子项</li></ul><p><strong>具体代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> Rx, &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs/Rx'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; setupRxDevtools &#125; <span class="keyword">from</span> <span class="string">'rx-devtools/rx-devtools'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'rx-devtools/add/operator/debug'</span>;</span><br><span class="line"></span><br><span class="line">setupRxDevtools();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SEARCH_REPOS = <span class="string">'https://api.github.com/search/repositories?sort=stars&amp;order=desc&amp;q='</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入关键字进行异步查找并排序</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">let</span> input$ = Observable.fromEvent(input, <span class="string">'input'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app$ = input$</span><br><span class="line">    .debounceTime(<span class="number">200</span>)</span><br><span class="line">    .debug(<span class="string">'查询'</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">    .filter(<span class="function">(<span class="params">text</span>) =&gt;</span> !!text)</span><br><span class="line">    .switchMap(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: SEARCH_REPOS + key,</span><br><span class="line">                success: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> result = data.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.name)</span><br><span class="line">                    observer.next(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// outerVal就是输入框的内容值，</span></span><br><span class="line">        <span class="comment">// innerVal就是请求后的结果数据</span></span><br><span class="line">    &#125;, (outerVal, innerVal) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> innerVal.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.includes(outerVal))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 长度排序</span></span><br><span class="line">    .map(<span class="function"><span class="params">data</span> =&gt;</span> data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.length - b.length))</span><br><span class="line">    <span class="comment">// 清空内容</span></span><br><span class="line">    .do(<span class="function"><span class="params">()</span> =&gt;</span> $(<span class="string">'#list-group'</span>).html(<span class="string">''</span>))</span><br><span class="line">    <span class="comment">// 数据转流</span></span><br><span class="line">    .mergeMap(<span class="function"><span class="params">data</span> =&gt;</span> Observable.from(data))</span><br><span class="line">    <span class="comment">// 转成jq对象</span></span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> $(<span class="string">`&lt;li&gt;<span class="subst">$&#123;item&#125;</span>&lt;/li&gt;`</span>))</span><br><span class="line">    <span class="comment">// 添加到列表里</span></span><br><span class="line">    .do(<span class="function"><span class="params">$dom</span> =&gt;</span> $(<span class="string">'#list-group'</span>).append($dom))</span><br><span class="line">    <span class="comment">// 背景颜色切换</span></span><br><span class="line">    .mergeMap(toggleBgColor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 背景颜色切换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleBgColor</span>(<span class="params">$dom</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建鼠标移入数据流</span></span><br><span class="line">    <span class="keyword">let</span> mouseover$ = Observable.fromEvent($dom, <span class="string">'mouseover'</span>)</span><br><span class="line">    <span class="comment">// 创建鼠标移出数据流</span></span><br><span class="line">    <span class="keyword">let</span> mouseout$ = Observable.fromEvent($dom, <span class="string">'mouseout'</span>)</span><br><span class="line">    <span class="comment">// 创建鼠标点击数据流</span></span><br><span class="line">    <span class="keyword">let</span> click$ = Observable.fromEvent($dom, <span class="string">'click'</span>)</span><br><span class="line">    click$ = click$.<span class="keyword">do</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        $(e.target).remove()</span><br><span class="line">    &#125;)</span><br><span class="line">    mouseover$ = mouseover$.<span class="keyword">do</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        $(e.target).css(<span class="string">'backgroundColor'</span>, <span class="string">'green'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    mouseout$ = mouseout$.<span class="keyword">do</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        $(e.target).css(<span class="string">'backgroundColor'</span>, <span class="string">'white'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并数据流转为其它数据</span></span><br><span class="line">    <span class="keyword">return</span> mouseover$.merge(mouseout$, click$)</span><br><span class="line">        .map(<span class="function"><span class="params">$dom</span> =&gt;</span> $dom.target.innerHTML)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app$.subscribe(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><h5 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h5><p>其中使用了用于Rx的调试工具，需要安装两个东西</p><ol><li>npm install rx-devtools –save-dev</li><li>谷歌的扩展插件<a href="https://chrome.google.com/webstore/detail/rxjs-developer-tools/dedeglckjaldaochjmnochcfamanokie" target="_blank" rel="noopener">RxJS developer tools</a></li></ol><p>使用方式如上述代码所示，使用需要注意几个要点</p><ul><li>在顶部引入并执行<code>setupRxDevtools</code>方法</li><li><code>.debug(&#39;查询&#39;)</code>方法在需要调试的流中插入即可，<code>查询</code>名字可随意取</li><li>在页面刷新前需要打开<code>Rx Devtools</code>页签，如图：</li></ul><p><img src="/images/debug/rx1.png" alt="rx1"></p><ul><li>选中”查询”当有数据流产生时会同时映射到右图，点击相应的操作符上面的玻璃球，就能看到流进该操作的实时数据便于调试。</li></ul><p><img src="/images/debug/rx2.png" alt="rx2"></p><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><ul><li>这种编程体验很优雅，通过一个个操作符将应用需求组装起来，易扩展和维护，代码看起来很简洁干净。</li><li>操作符永远不破坏原始数据流仅仅返回新的数据流，所以仍然可以监听之前的数据流，如：<code>input$</code>和<code>app$</code>，map的操作并妨碍影响对<code>input$</code>的数据监听。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">let</span> input$ = Observable.fromEvent(input, <span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">let</span> app$ = input$.map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</span><br><span class="line"></span><br><span class="line">input$.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'A'</span>, val))</span><br><span class="line">app$.subscribe(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B'</span>, val))</span><br></pre></td></tr></table></figure><h3 id="相关文档："><a href="#相关文档：" class="headerlink" title="相关文档："></a>相关文档：</h3><p><a href="https://rxjs-cn.github.io/rxjs5-ultimate-cn/" target="_blank" rel="noopener">RxJS 5 基本原理</a><br><a href="http://cn.rx.js.org/" target="_blank" rel="noopener">RxJs中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=&quot;概述：&quot;&gt;&lt;/a&gt;概述：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;RxJS 是使用 Observables 基于可观测数据流在异步编程应用中的库，它使编写异步或基于回调的代码更容易。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决异步编程我们已经有了es6的Promise，但Rx是更好的方案。&lt;/p&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延迟执行&lt;/li&gt;
&lt;li&gt;可传送多个值&lt;/li&gt;
&lt;li&gt;可中途取消以及重试&lt;/li&gt;
&lt;li&gt;可保留值待后续发送&lt;/li&gt;
&lt;li&gt;函数式编程体验&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="web前端" scheme="//litten.me/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="//litten.me/tags/JavaScript/"/>
    
      <category term="Rxjs" scheme="//litten.me/tags/Rxjs/"/>
    
  </entry>
  
  <entry>
    <title>Promise实用理解</title>
    <link href="//litten.me/2018/03/20/promise/"/>
    <id>//litten.me/2018/03/20/promise/</id>
    <published>2018-03-20T07:47:28.000Z</published>
    <updated>2018-03-24T01:49:10.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Promise含义"><a href="#1-Promise含义" class="headerlink" title="1.Promise含义"></a>1.Promise含义</h3><blockquote><p>Promise 是异步编程的一种解决方案优于传统的解决方案——回调函数和事件。<br>简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br>Promise对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>resolved</code>（已成功）和<code>rejected</code>（已失败）。</p></blockquote><a id="more"></a><h3 id="2-Promise执行顺序"><a href="#2-Promise执行顺序" class="headerlink" title="2.Promise执行顺序"></a>2.Promise执行顺序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出:</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"><span class="comment">// 'c'</span></span><br><span class="line"><span class="comment">// 'd'</span></span><br><span class="line"><span class="comment">// 'a'</span></span><br></pre></td></tr></table></figure><p>要理解该输出顺序首先应该了解js的执行任务队列优先级（由高到低）</p><ul><li>主线程</li><li>Micro-task队列 (微任务)</li><li>Macro-tasks队列 (宏任务)</li></ul><p>首先<code>setTimeout</code>属于宏任务扔进Macro-tasks队列，新建实例<code>Promise</code>时接受一个回调函数作为参数，注意此时该回调函数属于主线程会立刻执行，输出<code>&#39;b&#39;</code>紧接着执行<code>resolve</code>也就意味着该<code>promise</code>对象的状态将从<code>pending</code>更新为<code>resolved</code>，其挂载的回调函数也就是then里面的参数函数并不会立即执行，因为它属于微任务，所以丢进Micro-task队列。接下来输出<code>&#39;c&#39;</code>，到目前为止主线程任务已经结束，接着执行微任务输出<code>&#39;d&#39;</code>,最后执行宏任务输出<code>&#39;a&#39;</code>。</p><h3 id="3-Promise状态更新"><a href="#3-Promise状态更新" class="headerlink" title="3.Promise状态更新"></a>3.Promise状态更新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">    resolve(<span class="string">'p1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'p2'</span>)</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'p3'</span>)</span><br><span class="line">        resolve(<span class="string">'p3'</span>)</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line">p3.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>, value);</span><br><span class="line">&#125;, (value) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p1:'</span>, p1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p2:'</span>, p2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p3:'</span>, p3);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1:'</span>, p1);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2:'</span>, p2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p3:'</span>, p3);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line"><span class="comment">// p1: Promise &#123;[[resolved]]: "p1"&#125;</span></span><br><span class="line"><span class="comment">// p2: Promise &#123;[[pending]]&#125;</span></span><br><span class="line"><span class="comment">// p3: Promise &#123;[[pending]]&#125;</span></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// error p3</span></span><br><span class="line"><span class="comment">// p1: Promise &#123;[[resolved]]: "p1"&#125;</span></span><br><span class="line"><span class="comment">// p2: Promise &#123;[[resolved]]: "p2"&#125;</span></span><br><span class="line"><span class="comment">// p3: Promise &#123;[[rejected]]: "p3"&#125;</span></span><br></pre></td></tr></table></figure><p>p1最新创建就调用了<code>resolve</code>则它的状态立刻变为<code>resolved</code>，值为p1，但此时p2和p3都为<code>pending</code>状态，100毫秒后p2输出值p2且状态转为<code>resolved</code>。<br>p3首先调用了<code>reject</code>则其状态转为<code>rejected</code>，值为p3，尽管下一行又调用了resolve但并没有任何作用忽略成功的回调，只有<code>error p3</code>。<br>这段实验也显示出Promise的一个特点</p><ul><li>调用then方法传入回调可以从外部接受promise的异步返回数据value,当嵌套多级异步操作时这种优势更大。</li><li>状态的不可逆性，Promise的状态和值确定下来，后续再调用resolve或reject方法，不能改变它的状态和值。</li></ul><h3 id="3-Promise之then实例方法"><a href="#3-Promise之then实例方法" class="headerlink" title="3.Promise之then实例方法"></a>3.Promise之then实例方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'a'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;               </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一个"</span> + value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value + <span class="string">'b'</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;              </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二个"</span> + value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第三个"</span> + value);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;              </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第四个"</span> + value);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第四个error"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个a</span></span><br><span class="line"><span class="comment">// 第二个ab</span></span><br><span class="line"><span class="comment">// 第三个undefined</span></span><br><span class="line"><span class="comment">// 第四个error ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p><code>then</code>方法是Promise的实例方法，调用<code>then</code>后的返回值依然是一个promise对象，注意它是<strong>全新的promise对象</strong>，一般可以看到<code>then</code>的链式调用，这里需要注意区别于jQuery的链式调用。jQuery是返回调用对象本身。当链式调用时要注意不能被它绕晕了，要抓住一个重点，我们只是在调用<code>then</code>方法而已，给它传参只是定义函数，并没有执行！什么时候执行？是根据你的异步操作后的promise状态如何更新以及何时更新而确定。<br>传给<code>then</code>的回调函数中的返回值影响着最终返回出的promise对象，参数的返回值一般有三种情况。</p><ul><li>一个普通的同步值，或者没写返回值默认就是<code>undefined</code>，当然它也属于普通同步值。则<code>then</code>最终返回的是状态是<code>resolve</code>成功的Promise对象，如上段代码的第三个输出，它的前一个then方法内部没有返回值则默认<code>undefined</code>，接下来就直接走进第三个<code>then</code>方法，且值<code>value</code>就是<code>undefined</code>。</li><li>返回新的Promise对象，<code>then</code>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。如第二个输出，会等待上个then方法返回的新Promise对象状态的更新来确定，且会等待它的更新以及将最后的值传过来，这种情况也是当有多级异步操作所使用的方式。</li><li><code>throw</code>一个同步异常，<code>then</code>方法将返回一个<code>rejected</code>状态的Promise, 值是该异常。如第四个输出！</li></ul><h3 id="4-Promise之catch实例方法"><a href="#4-Promise之catch实例方法" class="headerlink" title="4.Promise之catch实例方法"></a>4.Promise之catch实例方法</h3><blockquote><p>Promise.prototype.catch方法是then(null, rejection)的别名，用于指定发生错误时的回调函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure><p>catch方法，它首先是捕捉处理错误，不论是promise调用了reject方法还是直接抛出错误，都会走到catch方法内进行处理。接下来就和then方法一样，返回的也是一个全新的Promise对象，错误处理的回调函数返回值同样有三种情况，具体看上个then方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'失败'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1then: success'</span>, val))</span><br><span class="line"> .then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2then: success'</span>, val))</span><br><span class="line"> .catch(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'3catch: error'</span>, val))</span><br><span class="line"> .catch(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4catch: error'</span>, val))</span><br><span class="line"> .then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'5then: success'</span>, val))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3catch: error 失败</span></span><br><span class="line"><span class="comment">// 5then: success undefined</span></span><br></pre></td></tr></table></figure><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<br>上段代码首先<code>p</code>这个Promise对象（状态是resolved）遇到第一个<code>then</code>会忽略掉它定义的成功回调，注意此时调用完第一个<code>then</code>方法后的返回值是<strong>全新的Promise对象</strong>！且状态同样是<code>resolved</code>，为何会这样？因为它把<code>p</code>的状态进行了一层包装也就作为了自己的状态，且值也和它一样！所以说<code>Promise</code>的状态具有传递性。</p><p>因为这个错误目前并没有被捕获处理，所以继续向后传递。同样遇到第二个<code>then</code>时我们可以当做跳过它，但发生的细节和第一个<code>then</code>同理,直到<code>3catch</code>将这个错误捕获，所以输出<code>3catch: error 失败</code>。上面也提到<code>catch</code>也就是<code>then</code>的一个别名而已，本质其实差不多。故此时<code>catch</code>调用后的返回值再次是一个全新的promise对象，那状态呢？因为这边给<code>catch</code>传递的参数并没有定义返回值，所以默认就是一个同步值<code>undefined</code>，则<code>catch</code>返回的promise对象的状态就是<code>resolved</code>。那么它调用最后一个<code>then</code>输出<code>5then: success undefined</code>，也就不难理解了。</p><h3 id="5-Promise之resolve、reject静态方法"><a href="#5-Promise之resolve、reject静态方法" class="headerlink" title="5.Promise之resolve、reject静态方法"></a>5.Promise之resolve、reject静态方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">'p1'</span>);</span><br><span class="line">p1.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'success'</span>, val), val =&gt; <span class="built_in">console</span>.log(<span class="string">'error'</span>, val))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">'p2'</span>);</span><br><span class="line">p2.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'success'</span>, val), val =&gt; <span class="built_in">console</span>.log(<span class="string">'error'</span>, val))</span><br></pre></td></tr></table></figure><p>当传入参数是一般同步值时则返回一个状态为resolve或reject的Promise对象，值也就是传入的参数，相应的会调用成功或失败的回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2)</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value)&#125;)</span><br><span class="line">p2.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value)&#125;)</span><br><span class="line">p3.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'p3='</span> + value)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// p1=1</span></span><br><span class="line"><span class="comment">// p2=1</span></span><br><span class="line"><span class="comment">// p3=1</span></span><br></pre></td></tr></table></figure><p>当传入一个Promise对象时，则<code>resolve</code>就直接返回该Promise对象，故<code>p1 === p2</code>为<code>true</code>，p3则为全新的Promise对象，但是它状态立刻变为<code>resolve</code>且值为p1，它会获取p1的状态和值作为自己的值。故<code>p3=1</code>。</p><h3 id="6-Promise之all、race静态方法"><a href="#6-Promise之all、race静态方法" class="headerlink" title="6.Promise之all、race静态方法"></a>6.Promise之all、race静态方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> wait = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">3</span>) * <span class="number">1000</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                resolve(who + <span class="string">' inner success'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(who + <span class="string">' inner error'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">        <span class="built_in">console</span>.log(who, <span class="string">'wait:'</span>, wait);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = timeout(<span class="string">'p1'</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = timeout(<span class="string">'p2'</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">success</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(success) &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(error) &#125;)</span><br><span class="line">p2.then(<span class="function">(<span class="params">success</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(success) &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(error) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// race只要有一个状态改变那就立即触发且决定整体状态失败还是成功.</span></span><br><span class="line"><span class="comment">// all只要有一个失败那就立即触发整体失败了，两个都成功整体才成功.</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">    .then(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'all success'</span>, args)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'someone error'</span>, args)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出(情况1)</span></span><br><span class="line"><span class="comment">// p1 wait: 3000</span></span><br><span class="line"><span class="comment">// p2 wait: 1000p2 inner error</span></span><br><span class="line"><span class="comment">// someone error [ 'p2 inner error' ]</span></span><br><span class="line"><span class="comment">// p1 inner success</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出(情况2)</span></span><br><span class="line"><span class="comment">// p1 wait: 2000</span></span><br><span class="line"><span class="comment">// p2 wait: 2000</span></span><br><span class="line"><span class="comment">// p1 inner success</span></span><br><span class="line"><span class="comment">// p2 inner success</span></span><br><span class="line"><span class="comment">// all success [ [ 'p1 inner success', 'p2 inner success' ] ]</span></span><br></pre></td></tr></table></figure><p>all、race方法接受数组作为参数，且数组每个成员都为Promise对象。如果不是的话就调用Promise.resolve方法，将其转为 Promise 实例，再进一步处理。使用表示要包装的多个promise异步操作来确定。具体可以看代码理解，要多动手自己试验！</p><h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰ECMAScript 6 入门 Promise</a><br><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Promise含义&quot;&gt;&lt;a href=&quot;#1-Promise含义&quot; class=&quot;headerlink&quot; title=&quot;1.Promise含义&quot;&gt;&lt;/a&gt;1.Promise含义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Promise 是异步编程的一种解决方案优于传统的解决方案——回调函数和事件。&lt;br&gt;简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。&lt;br&gt;Promise对象代表一个异步操作，有三种状态：&lt;code&gt;pending&lt;/code&gt;（进行中）、&lt;code&gt;resolved&lt;/code&gt;（已成功）和&lt;code&gt;rejected&lt;/code&gt;（已失败）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="//litten.me/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="//litten.me/tags/JavaScript/"/>
    
      <category term="Promise" scheme="//litten.me/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Vue数据绑定</title>
    <link href="//litten.me/2018/03/19/vueDataSub/"/>
    <id>//litten.me/2018/03/19/vueDataSub/</id>
    <published>2018-03-19T06:11:38.000Z</published>
    <updated>2018-03-24T01:49:10.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于vue数据绑定的极简原理"><a href="#关于vue数据绑定的极简原理" class="headerlink" title="关于vue数据绑定的极简原理"></a>关于vue数据绑定的极简原理</h4><p><img src="https://user-gold-cdn.xitu.io/2017/8/2/c00a07c463dd341d5c0e731a9ebdca52?imageView2/1/w/800/h/600/q/85/format/webp/interlace/1" width="150px" height="150px" alt="vue logo" title="vue logo"></p><a id="more"></a><p><strong><em>dep.js</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对订阅者进行收集、存储和通知</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @class      Dep (name)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="comment">// 通知所有的订阅者（Watcher），触发订阅者的相应逻辑处理</span></span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.update());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><ul><li><code>Dep</code>类用来实例一个个的收集器，每个收集器用来存储对单个数据的订阅者，当该项数据发生变化时统一的去通知他们</li><li><code>Dep.target</code>用来暂存当前订阅者</li></ul><p><strong><em>observer.js</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'./dep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给当前属性的值添加监听</span></span><br><span class="line">    observer(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value: '</span>, val)</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dep.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        set: <span class="function">(<span class="params">newVal</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'无需更新'</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'new value setted: '</span>, newVal)</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> defineReactive(value, key, value[key]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>核心方法<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>定义对象的属性访问器，从而达到对数据改变的监听。</li><li><code>observer</code>首先判断数据是否是对象，<code>Object.keys</code>遍历对象的每个字段对其执行<code>defineReactive</code>添加监听</li><li><code>defineReactive</code>首先进来实例化<code>Dep</code>，单个数据监听的收集器。这里再次对值<code>observer</code>实际上是类似递归，数据对象深层嵌套时继续监听。</li><li><code>enumerable、configurable</code>可枚举、可配置。<code>get</code>获取属性时，会把监听者添加到<code>dep</code>中，这边实际上是个闭包。<code>dep</code>收集器会常驻内存保留着。</li><li>当数据<code>set</code>设置时首先判断新值<code>newVal</code>是否与与旧值<code>val</code>相等，相等则无需更新，这边的旧值<code>val</code>也就是形参<code>val</code>也属于闭包。新旧值不等时则接下来由<code>dep.notify</code>来通知所有的监听者</li></ul><p><strong><em>watcher.js</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'./dep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm; <span class="comment">//vue数据主体</span></span><br><span class="line">        <span class="keyword">this</span>.expOrFn = expOrFn; <span class="comment">// 监听的字段</span></span><br><span class="line">        <span class="keyword">this</span>.cb = cb; <span class="comment">// 数据变化后的回调</span></span><br><span class="line">        <span class="keyword">this</span>.val = <span class="keyword">this</span>.get(); <span class="comment">// 初始化获取数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅数据更新时调用</span></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="comment">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="keyword">this</span>.vm._data[<span class="keyword">this</span>.expOrFn];</span><br><span class="line"></span><br><span class="line">        Dep.target = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>get</code>获取此刻的数据，首先会将自身实例挂在到<code>Dep.target</code>，其目的是访问<code>this.vm._data[this.expOrFn]</code>数据时触发监听器<code>observer.js</code>中，然后再重置<code>Dep.target</code>;</li><li><code>update</code>方法，数据更新后会由<code>dep</code>通知触发。从而执行回调<code>this.cb</code>，且把新值<code>this.val</code>传进回调,该方法是我们的最终目的，更新视图<code>view</code>;</li></ul><p><strong><em>vue.js</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Watcher <span class="keyword">from</span> <span class="string">'./watcher'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'./observer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$options = options;</span><br><span class="line">        <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data;</span><br><span class="line">        <span class="built_in">Object</span>.keys(<span class="keyword">this</span>._data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>._proxy(key));</span><br><span class="line"></span><br><span class="line">        observer(<span class="keyword">this</span>._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $watch(expOrFn, cb) &#123;</span><br><span class="line">        <span class="keyword">new</span> Watcher(<span class="keyword">this</span>, expOrFn, cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _proxy(key) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            get: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>._data[key],</span><br><span class="line">            set: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>._data[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>为使用方便把数据的监听同样添加到<code>Vue</code>实例中，通过<code>$watch</code>方法来定义监听的字段以及回调</li></ul><p><strong><em>main.js</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> demo = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'cheche'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">demo.$watch(<span class="string">"name"</span>, (value) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"【update view111】: "</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">demo.name = <span class="string">"meihao"</span>;</span><br></pre></td></tr></table></figure></p><ul><li>最后的使用示例</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关于vue数据绑定的极简原理&quot;&gt;&lt;a href=&quot;#关于vue数据绑定的极简原理&quot; class=&quot;headerlink&quot; title=&quot;关于vue数据绑定的极简原理&quot;&gt;&lt;/a&gt;关于vue数据绑定的极简原理&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/8/2/c00a07c463dd341d5c0e731a9ebdca52?imageView2/1/w/800/h/600/q/85/format/webp/interlace/1&quot; width=&quot;150px&quot; height=&quot;150px&quot; alt=&quot;vue logo&quot; title=&quot;vue logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="//litten.me/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="//litten.me/tags/JavaScript/"/>
    
      <category term="Vue" scheme="//litten.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>无锡游</title>
    <link href="//litten.me/2018/03/17/wuxiyou/"/>
    <id>//litten.me/2018/03/17/wuxiyou/</id>
    <published>2018-03-17T04:06:41.000Z</published>
    <updated>2018-03-24T01:49:10.337Z</updated>
    
    <content type="html"><![CDATA[<ul><li>三国城</li><li>水浒城</li><li>鼋头渚</li></ul><p><img src="/images/wuxiyou/IMG_1857.JPG"></p><a id="more"></a><p><img src="/images/wuxiyou/IMG_1769.JPG"></p><p><img src="/images/wuxiyou/IMG_1778.JPG"></p><p><img src="/images/wuxiyou/IMG_1780.JPG"></p><p><img src="/images/wuxiyou/IMG_1790.JPG"></p><p><img src="/images/wuxiyou/IMG_1812.JPG"></p><p><img src="/images/wuxiyou/IMG_1830.JPG"></p><p><img src="/images/wuxiyou/IMG_1844.JPG"></p><p><img src="/images/wuxiyou/IMG_1846.JPG"></p><p><img src="/images/wuxiyou/IMG_1852.JPG"></p><p><img src="/images/wuxiyou/IMG_1853.JPG"></p><p><img src="/images/wuxiyou/IMG_1858.JPG"></p><p><img src="/images/wuxiyou/IMG_1859.JPG"></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;三国城&lt;/li&gt;
&lt;li&gt;水浒城&lt;/li&gt;
&lt;li&gt;鼋头渚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/wuxiyou/IMG_1857.JPG&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="//litten.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="旅游" scheme="//litten.me/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>My Home</title>
    <link href="//litten.me/2018/03/17/my_home/"/>
    <id>//litten.me/2018/03/17/my_home/</id>
    <published>2018-03-17T02:19:02.210Z</published>
    <updated>2018-12-08T05:11:36.534Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Hejianbo</li><li>Liumeihao</li><li>Heyujia</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Hejianbo&lt;/li&gt;
&lt;li&gt;Liumeihao&lt;/li&gt;
&lt;li&gt;Heyujia&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="生活" scheme="//litten.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="有趣" scheme="//litten.me/tags/%E6%9C%89%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>谷歌调试·三脚猫</title>
    <link href="//litten.me/2018/03/09/chrome-debug/"/>
    <id>//litten.me/2018/03/09/chrome-debug/</id>
    <published>2018-03-09T06:59:04.000Z</published>
    <updated>2018-03-24T01:49:10.332Z</updated>
    
    <content type="html"><![CDATA[<p>网上也有很多关于调试的技巧，小编断断续续也看过不少，可能由于技术以及所遇场景有限，很多技巧看完就忘了。能记住的也就是平时经常用的一些小技巧，废话少说直接来！</p><a id="more"></a><h3 id="1-搜索search："><a href="#1-搜索search：" class="headerlink" title="1.搜索search："></a>1.搜索search：</h3><p><img src="/images/debug/1.png" alt="search_img"><br>首先我需要快速的定位到我需要调试的代码处，谷歌<code>f12</code>调出开发者调试工具，底部如果压根没看到<code>底部栏</code>, <code>Esc</code>按钮快速切换底部导航栏的显示与隐藏，如果未看到<code>search栏</code>则在上图第一个箭头打开它，右侧的两个复选框</p><ul><li><code>Ignore case</code>     忽略大小写</li><li><code>Regular expression</code>  正则匹配</li></ul><p>输入关键词回车后，搜索栏会以风速展示与输入的关键词匹配到的全步代码，快到没朋友！直接点击想要去的那一行代码，鼠标焦点也帮你定位到源码。如下图：<br><img src="/images/debug/2.png" alt="search_img"></p><h3 id="2-断点breakpoint："><a href="#2-断点breakpoint：" class="headerlink" title="2.断点breakpoint："></a>2.断点breakpoint：</h3><p><img src="/images/debug/3.png" alt="breakpoint_img"><br>打断点是调试的最重要手段，当程序出现问题，首先想到的就是跟着程序走，一步一步看程序的变化，问题到底在哪一步。<br>点击<code>A</code>处的任意行即可生成断点，再次点击即可清除该断点。<br>也可以右击进入选择栏添加和移除（麻烦）</p><p><strong>一个酷的功能: </strong><code>Add conditional breakpoint</code>添加条件语句，只有当输入的条件语句为<code>true</code>时才会停住。<br><strong>有个坑：</strong><code>Blackbox script</code>不要点，否则断点就玩不了了。 </p><p><strong>注意：</strong><br>新手会疑惑，我断点打在这了，程序执行为什么没有停在这，要知道你是页面已经加载完再打的断点还有毛用，所以你打完断点再<code>f5</code>刷新页面即可，让js重新执行到你断点处即可。<br>对于某个还未执行的函数，比如某个响应事件可以打完断点后再去鼠标点击页面元素，然后响应该事件进入断点跟进。</p><p><strong>快捷键：</strong></p><ul><li>f10 跟进当前函数的下一行</li><li>f11 继续跟进当前代码行调用的另一个函数</li><li>Shift + f11 跳出当前函数回到前一个执行函数断点</li><li>Ctrl + \  忽略当前断点跟进直到有下一个断点继续停住</li><li>Ctrl + f8  暂时禁用全部断点</li></ul><p><img src="/images/debug/4.png" alt="breakpoint_img"><br><strong>技巧：</strong></p><ol><li>鼠标放在<code>B</code>处任意变量名上即可出现当前变量此时的值, 以及接受的参数<code>selected_smallid</code>和<code>data</code>,编写函数时尽量的减少全局变量，而是把数据以参数的形式传进来，这样也方便调试。</li><li>有时我们已经在多处添加的断点，如果一个个的去取消必须要找到它们（浪费时间），右侧<code>C</code>处即是全部断点的集合，右击可以单独移除、禁用、激活某个断点且不需要找它的位置，也可以移除全部，太方便了有木有!</li><li>跟进断点有时候需要跳到<code>ToolFunc.getTargetItemData</code>方法内部继续跟进<code>f11</code>，但是很多时候发现这个函数不是自己写的，代码太多太多，仿佛陷进深渊回不来了。那就需要跳出<code>shift + f11</code>, 但有时候依然跳不出来怎么办？<br>那就如图在<code>151058</code>处或自己想重点看的那一行打个断点，然后<code>ctrl + \</code>，完美！</li><li><code>C</code>那一栏还有<code>Call Stack</code>也很重要，它记录着函数的调用栈，就是来到当前函数前都执行过哪些函数</li><li><code>D</code>处，有些断点甚至刻意不需要知道它在哪一行，直接在<code>Event Listener Breakpoints</code>栏内指定该响应的事件即可断点（主要用在别人的页面）</li><li>打了很多断点，某一次测试想让他们不生效，但是又不能删除以免过一会儿还要一个个添加断点，这是后<code>Ctrl + f8</code>灵活的停用和激活断点非常666！</li></ol><h3 id="3-打印console："><a href="#3-打印console：" class="headerlink" title="3.打印console："></a>3.打印console：</h3><p><img src="/images/debug/5.png" alt="console_img"><br>打印信息是最清楚了,那些<code>console.info</code>之类的就不说了。</p><p><strong>技巧：</strong></p><ol><li>连着上一个断点继续说，这边控制台起始就相当于进入到该断点的作用域了，比如直接在控制台<code>A</code>输入<code>targetData</code>回车即可看到它的数据内容<code>B</code>。打印<code>this</code>也是对的，<code>this</code>都给你了想干嘛请自便。</li><li>在<code>B</code>上右击选择<code>Store as global variable</code>，随即便打印<code>C</code>。顾名思义把对象的应用拷贝了一份给全局，属性名<code>temp1</code>,如果继续在其它打印的对象上再来一次，则出现<code>temp2</code>，以此类推！</li><li>既然是对象的引用那么<code>E</code>可以查看对象某个属性值，甚至是修改它<code>F</code>，然后继续断点跟进，这样省去了进来的数据不是想要测试的数据还必须重新来的麻烦！</li></ol><h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>暂且就说这么多，有机会再添加吧，byebye~~~！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上也有很多关于调试的技巧，小编断断续续也看过不少，可能由于技术以及所遇场景有限，很多技巧看完就忘了。能记住的也就是平时经常用的一些小技巧，废话少说直接来！&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="//litten.me/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="//litten.me/tags/JavaScript/"/>
    
      <category term="调试" scheme="//litten.me/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>LayaBox源码解析-Handler</title>
    <link href="//litten.me/2018/03/09/laya-box-Handler/"/>
    <id>//litten.me/2018/03/09/laya-box-Handler/</id>
    <published>2018-03-09T03:30:09.000Z</published>
    <updated>2018-03-24T01:49:10.333Z</updated>
    
    <content type="html"><![CDATA[<p>(本文是as和js混合，其实两者差不多，一个妈生的。^_^!!)</p><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><blockquote><p>推荐使用 <code>Handler.create()</code> 方法从对象池创建，减少对象创建消耗。<br>创建的 Handler 对象不再使用后，可以使用 <code>Handler.recover()</code>将其回收到对象池</p></blockquote><p><strong>注意：</strong> 由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。</p><a id="more"></a><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul><li>绑定作用域</li><li>携带参数</li><li>是否执行一次以及回收</li></ul><p>我用普通函数加上<code>call</code>、<code>apply</code>修正<code>this</code>指向外加标志符之类的也能现实为什么非要用它呢？<br>当应用程序变得越来越庞大和复杂时，自然而然就需要有一个统一管理的处理器。比如在A处定义好函数、作用域和参数但是此时不想立刻执行，待到B处再执行，则作用就体现出来，以及参数可以两处进行累加、对函数的及时回收将变得异常方便。把这些细节处理隐藏起来，暴露在外可以做到简洁，且对新手使用更加友好！</p><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><ul><li><code>static</code> _pool:Array = [];  //对象池用于缓存节约资源</li><li><code>static</code> _gid:int = 1;       //用于计数id</li><li>caller:*;          //执行域也叫执行上下文对象</li><li>method:Function;  //处理方法（主角）</li><li>args:Array;          //携带的参数</li><li>once:Boolean = false;  //是否只执行一次</li><li>_id:int = 0;      //携带的id</li></ul><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p><strong>1. create:</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">(caller:*, method:Function, args:Array = null, once:Boolean = true)</span>:Handler </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_pool.length) <span class="keyword">return</span> _pool.pop().setTo(caller, method, args, once);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Handler(caller, method, args, once);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建handler实例的推荐方式是<code>Handler.create</code>,原因在于方法第一步的判断，如果缓存对象池内有缓存则直接从缓存取出从而节约资源。接下来不论是<code>setTo</code>还是<code>new Handler</code>作用是一样的，后者也是在调用前者。</p><p><strong>2. setTo:</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setTo</span><span class="params">(caller:*, method:Function, args:Array, once:Boolean)</span>:Handler </span>&#123;</span><br><span class="line">_id = _gid++;</span><br><span class="line"><span class="keyword">this</span>.caller = caller;</span><br><span class="line"><span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="keyword">this</span>.args = args;</span><br><span class="line"><span class="keyword">this</span>.once = once;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先静态属性<code>_gid</code>累计自增作为实例属性<code>_id</code>的值，表示每个实例有一个自己独一无二的<code>_id</code>，以及给各自实例属性赋值。</p><p><strong>3. run:</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span>:* </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (method == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> id:int = _id;</span><br><span class="line"><span class="keyword">var</span> result:* = method.apply(caller, args);</span><br><span class="line">_id === id &amp;&amp; once &amp;&amp; recover();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>method</code>就是最初传进来的处理函数，通过<code>method.apply(caller, args)</code>传进<code>this</code>指向以及携带的参数列表<code>args</code>。且该处理函数的返回值同时也作为<code>run</code>的返回值返回。<code>_id === id &amp;&amp; once &amp;&amp; recover();</code>保证id不变的情况下如果是一次性处理函数则及时<code>recover</code>回收。</p><p><strong>4. runWith:</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">runWith</span><span class="params">(data:*)</span>:* </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> id:int = _id;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">var</span> result:* = method.apply(caller, args);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (args) result = method.apply(caller, args.concat(data));</span><br><span class="line">    <span class="keyword">else</span> result = method.apply(caller, data);</span><br><span class="line">    _id === id &amp;&amp; once &amp;&amp; recover();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>runWith</code>与<code>run</code>的区别就是它可以继续传入参数与之前的参数通过<code>args.concat(data)</code>累加作为<code>method.apply</code>执行的第二个参数。<br><strong>注意：</strong><code>concat</code>方法的参数可以是数组也可以是非数组。数组的话就只是展开一维数组，非数组的话就直接当做<code>length</code>为1的一维数组合并。</p><p><strong>5. recover:</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">recover</span><span class="params">()</span>:void </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _id = <span class="number">0</span>;</span><br><span class="line">        _pool.push(clear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但凡<code>_id</code>大于0的则需要回收，因为已经回收的<code>_id</code>随即赋值为0了，并且回收扔进该类的静态属性<code>_pool</code>数组对象池中，以待下次利用。</p><p><strong>6. clear:</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">clear</span><span class="params">()</span>:Handler </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.caller = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.args = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>清除自身但是<code>id</code>并不在这边清0，那是交给回收时清除，这也很好理解只是清除自身，可能没用了但是他还在这，并没有回收它，故<code>id</code>目前依然保留。</p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ol><li>Laya.loader.load(url, Handler.create(this, function(){}));</li><li>node.mouseHandler = Handler.create(this, function(){}, null, false);</li><li>list.selectHandler = Handler.create(this, function(){}, null, false);</li></ol><p><strong>常见误区：</strong><br>当需要多次执行时的场景时，<code>Handler.create()</code>方法的第四个参数是否是一次性，当不传该参数默认是<code>true</code>,事件则只会相应一次。常出现在给元素添加事件和加载资源时的进度条更新的回调函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(本文是as和js混合，其实两者差不多，一个妈生的。^_^!!)&lt;/p&gt;
&lt;h3 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=&quot;概述：&quot;&gt;&lt;/a&gt;概述：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;推荐使用 &lt;code&gt;Handler.create()&lt;/code&gt; 方法从对象池创建，减少对象创建消耗。&lt;br&gt;创建的 Handler 对象不再使用后，可以使用 &lt;code&gt;Handler.recover()&lt;/code&gt;将其回收到对象池&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="//litten.me/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="LayaBox" scheme="//litten.me/tags/LayaBox/"/>
    
      <category term="ActionScript" scheme="//litten.me/tags/ActionScript/"/>
    
      <category term="JavaScript" scheme="//litten.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的同源策略及解决方案</title>
    <link href="//litten.me/2018/03/06/same_origin_policy/"/>
    <id>//litten.me/2018/03/06/same_origin_policy/</id>
    <published>2018-03-06T07:20:39.000Z</published>
    <updated>2018-03-17T02:19:02.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-含义"><a href="#一-含义" class="headerlink" title="一. 含义"></a>一. 含义</h3><p>最初是指一张网页不能读取另一张网页的cookie,除非两张网页是同源的。</p><ul><li>协议相同</li><li>域名相同</li><li>端口号相同</li></ul><a id="more"></a><p><strong>例子</strong><br><code>http://www.example.com/dir/page.html</code><br>协议是<code>http：//</code>, 域名是<code>www.example.com</code>,端口号是<code>80</code>（默认可以省略）</p><p><strong>目的</strong><br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p><p><strong>限制范围</strong></p><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取。</li><li>DOM无法获得。</li><li>AJAX无法请求</li></ol><p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面详细介绍，如何规避上面三种限制。</p><h3 id="二-Cookie"><a href="#二-Cookie" class="headerlink" title="二. Cookie"></a>二. Cookie</h3><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = &apos;example.com&apos;;</span><br></pre></td></tr></table></figure></p><p>注意，这种方法只适用于 <code>Cookie</code>和 <code>iframe</code> 窗口，<code>LocalStorage</code> 和 <code>IndexDB</code> 无法通过这种方法，规避同源政策，而要使用下文介绍的<code>PostMessage API</code>。</p><p>另外，服务器也可以在设置<code>Cookie</code>的时候，指定<code>Cookie</code>的所属域名为一级域名，比如<code>.example.com</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: key=value; domain=.example.com; path=/</span><br></pre></td></tr></table></figure></p><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p><h3 id="三-iframe"><a href="#三-iframe" class="headerlink" title="三. iframe"></a>三. iframe</h3><p>如果两个网页不同源，就无法拿到对方的<code>DOM</code>。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p><p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到<code>DOM</code>。</p><p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p><ol><li>片段标识符</li><li>window.name</li><li>postmessage 垮文档通信api</li></ol><h5 id="1-片段标识符"><a href="#1-片段标识符" class="headerlink" title="1.片段标识符"></a>1.片段标识符</h5><p>（fragment identifier）指的是，URL的#号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。也称做哈希值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line">function checkMessage() &#123;</span><br><span class="line">  var message = window.location.hash;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-window-name"><a href="#2-window-name" class="headerlink" title="2.window.name"></a>2.window.name</h5><p>浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p><p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。<br>这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p><h5 id="3-window-postMessage"><a href="#3-window-postMessage" class="headerlink" title="3.window.postMessage"></a>3.window.postMessage</h5><p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p><p>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://bbb.com'</span>, <span class="string">'title'</span>);</span><br><span class="line">popup.postMessage(<span class="string">'Hello World!'</span>, <span class="string">'http://bbb.com'</span>);</span><br></pre></td></tr></table></figure></p><p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即<code>&quot;协议 + 域名 + 端口&quot;</code>。也可以设为*，表示不限制域名，向所有窗口发送。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子窗口向父窗口发送消息的写法类似。</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">'Nice to see you'</span>, <span class="string">'http://aaa.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//父窗口和子窗口都可以通过message事件，监听对方的消息。</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>message事件的事件对象event，提供以下三个属性。</p><ul><li>event.source：发送消息的窗口</li><li>event.origin: 消息发向的网址</li><li>event.data: 消息内容</li></ul><p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.data === <span class="string">'Hello World'</span>) &#123;</span><br><span class="line">      event.source.postMessage(<span class="string">'Hello'</span>, event.origin);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四-AJAX"><a href="#四-AJAX" class="headerlink" title="四.AJAX"></a>四.AJAX</h3><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p><p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p><ol><li>JSONP</li><li>WebSocket</li><li>CORS</li></ol><h5 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h5><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p><p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p><p>首先，网页动态插入元素，由它向跨源网址发出请求。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Your public IP address is: '</span> + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。</p><p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  <span class="string">"ip"</span>: <span class="string">"8.8.8.8"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p><h5 id="2-WebSocket"><a href="#2-WebSocket" class="headerlink" title="2.WebSocket"></a>2.WebSocket</h5><p>WebSocket是一种通信协议，使用<code>ws://（非加密）</code>和<code>wss://（加密）</code>作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p><h5 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h5><p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-含义&quot;&gt;&lt;a href=&quot;#一-含义&quot; class=&quot;headerlink&quot; title=&quot;一. 含义&quot;&gt;&lt;/a&gt;一. 含义&lt;/h3&gt;&lt;p&gt;最初是指一张网页不能读取另一张网页的cookie,除非两张网页是同源的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议相同&lt;/li&gt;
&lt;li&gt;域名相同&lt;/li&gt;
&lt;li&gt;端口号相同&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="web前端" scheme="//litten.me/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Cookie" scheme="//litten.me/tags/Cookie/"/>
    
      <category term="AJAX" scheme="//litten.me/tags/AJAX/"/>
    
      <category term="Iframe" scheme="//litten.me/tags/Iframe/"/>
    
  </entry>
  
</feed>
